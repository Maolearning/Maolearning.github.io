<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ä¸­å›½è±¡æ£‹</title>
    <style>
        body { background: #e6d7b5; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; font-family: "KaiTi", "æ¥·ä½“", serif; user-select: none; }
        canvas { background: #f0cea0; box-shadow: 0 5px 15px rgba(0,0,0,0.3); border-radius: 4px; cursor: pointer; border: 2px solid #5a3d1c; }
        .info { margin-top: 15px; font-size: 20px; font-weight: bold; color: #4a3015; display: flex; gap: 20px; }
        button { padding: 8px 16px; font-size: 16px; cursor: pointer; border-radius: 6px; border: 1px solid #886; background: #fff; }
    </style>
</head>
<body>
    <canvas id="chess" width="450" height="500"></canvas>
    <div class="info">
        <span id="turn-text">ğŸ”´ çº¢æ–¹èµ°æ£‹</span>
        <button onclick="initGame()">ğŸ”„ é‡æ–°å¼€å§‹</button>
    </div>

    <script>
        const canvas = document.getElementById('chess');
        const ctx = canvas.getContext('2d');
        const W = 450, H = 500;
        const GRID = 50;
        const OFFSET = 25;
        
        let pieces = [];
        let selected = null; // å½“å‰é€‰ä¸­çš„æ£‹å­
        let turn = 'red'; // 'red' or 'black'

        // æ£‹å­å®šä¹‰
        const initMap = [
            ['c_ju', 'c_ma', 'c_xiang', 'c_shi', 'c_jiang', 'c_shi', 'c_xiang', 'c_ma', 'c_ju'],
            [],
            ['', 'c_pao', '', '', '', '', '', 'c_pao', ''],
            ['c_zu', '', 'c_zu', '', 'c_zu', '', 'c_zu', '', 'c_zu'],
            [], [],
            ['h_zu', '', 'h_zu', '', 'h_zu', '', 'h_zu', '', 'h_zu'],
            ['', 'h_pao', '', '', '', '', '', 'h_pao', ''],
            [],
            ['h_ju', 'h_ma', 'h_xiang', 'h_shi', 'h_shuai', 'h_shi', 'h_xiang', 'h_ma', 'h_ju']
        ];

        const labelMap = {
            'ju': 'è½¦', 'ma': 'é©¬', 'xiang': 'è±¡', 'shi': 'å£«', 'jiang': 'å°†', 'pao': 'ç‚®', 'zu': 'å’',
            'shuai': 'å¸…', 'bing': 'å…µ' // çº¢æ–¹ç‰¹æ®Šå­—åœ¨ç»˜åˆ¶æ—¶å¤„ç†
        };

        function initGame() {
            pieces = [];
            turn = 'red';
            document.getElementById('turn-text').innerText = "ğŸ”´ çº¢æ–¹èµ°æ£‹";
            selected = null;

            for(let y=0; y<10; y++) {
                for(let x=0; x<9; x++) {
                    const key = initMap[y] ? initMap[y][x] : '';
                    if(key) {
                        const color = key.startsWith('h') ? 'red' : 'black'; // h=hong(red), c=black
                        const type = key.split('_')[1];
                        pieces.push({ x, y, color, type });
                    }
                }
            }
            draw();
        }

        function drawBoard() {
            ctx.fillStyle = "#e8cba5";
            ctx.fillRect(0,0,W,H);
            
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#5a3d1c";
            ctx.beginPath();

            // æ¨ªçº¿
            for(let i=0; i<10; i++) {
                ctx.moveTo(OFFSET, OFFSET + i*GRID);
                ctx.lineTo(W-OFFSET, OFFSET + i*GRID);
            }
            // ç«–çº¿
            for(let i=0; i<9; i++) {
                ctx.moveTo(OFFSET + i*GRID, OFFSET);
                ctx.lineTo(OFFSET + i*GRID, OFFSET + 4*GRID); // ä¸ŠåŠ
                ctx.moveTo(OFFSET + i*GRID, OFFSET + 5*GRID);
                ctx.lineTo(OFFSET + i*GRID, H-OFFSET); // ä¸‹åŠ
            }
            // ä¸¤ä¾§è¾¹çº¿å°å£
            ctx.moveTo(OFFSET, OFFSET + 4*GRID); ctx.lineTo(OFFSET, OFFSET + 5*GRID);
            ctx.moveTo(W-OFFSET, OFFSET + 4*GRID); ctx.lineTo(W-OFFSET, OFFSET + 5*GRID);

            // ä¹å®«æ ¼æ–œçº¿
            ctx.moveTo(OFFSET+3*GRID, OFFSET); ctx.lineTo(OFFSET+5*GRID, OFFSET+2*GRID);
            ctx.moveTo(OFFSET+5*GRID, OFFSET); ctx.lineTo(OFFSET+3*GRID, OFFSET+2*GRID);
            ctx.moveTo(OFFSET+3*GRID, H-OFFSET); ctx.lineTo(OFFSET+5*GRID, H-OFFSET-2*GRID);
            ctx.moveTo(OFFSET+5*GRID, H-OFFSET); ctx.lineTo(OFFSET+3*GRID, H-OFFSET-2*GRID);

            ctx.stroke();

            // æ¥šæ²³æ±‰ç•Œ
            ctx.font = "28px KaiTi";
            ctx.fillStyle = "#5a3d1c";
            ctx.fillText("æ¥š æ²³", OFFSET+1.5*GRID, OFFSET+4.65*GRID);
            ctx.fillText("æ±‰ ç•Œ", OFFSET+5.5*GRID, OFFSET+4.65*GRID);
        }

        function drawPieces() {
            pieces.forEach(p => {
                const cx = OFFSET + p.x * GRID;
                const cy = OFFSET + p.y * GRID;
                
                // æ£‹å­åº•
                ctx.beginPath();
                ctx.arc(cx, cy, 22, 0, 2*Math.PI);
                ctx.fillStyle = "#f3dcb8";
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = p.color === 'red' ? '#c00' : '#111';
                
                // é€‰ä¸­é«˜äº®
                if(selected && selected.x === p.x && selected.y === p.y) {
                    ctx.strokeStyle = "#00f";
                    ctx.lineWidth = 3;
                }
                ctx.stroke();

                // æ–‡å­—
                ctx.fillStyle = p.color === 'red' ? '#c00' : '#111';
                ctx.font = "bold 24px KaiTi";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                let txt = labelMap[p.type];
                if(p.color === 'red' && p.type === 'xiang') txt = 'ç›¸';
                if(p.color === 'red' && p.type === 'zu') txt = 'å…µ';
                ctx.fillText(txt, cx, cy);
            });
        }

        function draw() {
            drawBoard();
            drawPieces();
        }

        canvas.onclick = function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left - OFFSET) / GRID);
            const y = Math.round((e.clientY - rect.top - OFFSET) / GRID);

            if(x < 0 || x > 8 || y < 0 || y > 9) return;

            // 1. ç‚¹å‡»è‡ªå·±æ–¹æ£‹å­ -> é€‰ä¸­
            const clickedPiece = pieces.find(p => p.x === x && p.y === y);
            if(clickedPiece && clickedPiece.color === turn) {
                selected = clickedPiece;
                draw();
                return;
            }

            // 2. å·²é€‰ä¸­æ£‹å­ï¼Œç‚¹å‡»ç›®æ ‡ä½ç½® -> ç§»åŠ¨æˆ–åƒå­
            if(selected) {
                // ç®€å•çš„"è‡ªç”±ç§»åŠ¨"è§„åˆ™ (ä¸å¼ºåˆ¶æ ¡éªŒé©¬è„šç­‰ï¼Œä¸ºäº†ä»£ç ç®€æ´)
                // åªè¦ä¸æ˜¯åŸä½ç½®ï¼Œä¸”ç›®æ ‡ä¸æ˜¯å·±æ–¹æ£‹å­
                if(clickedPiece && clickedPiece.color === turn) return; // ç‚¹åˆ°äº†é˜Ÿå‹ï¼Œå¿½ç•¥

                // ç§»é™¤è¢«åƒæ‰çš„æ£‹å­
                if(clickedPiece) {
                    const idx = pieces.indexOf(clickedPiece);
                    if(idx > -1) pieces.splice(idx, 1);
                    // æ£€æŸ¥æ˜¯å¦åƒæ‰å°†å¸…
                    if(clickedPiece.type === 'jiang' || clickedPiece.type === 'shuai') {
                        alert((turn === 'red' ? "çº¢æ–¹" : "é»‘æ–¹") + "èƒœåˆ©ï¼");
                        initGame();
                        return;
                    }
                }

                // ç§»åŠ¨
                selected.x = x;
                selected.y = y;
                selected = null;
                
                // æ¢æ‰‹
                turn = turn === 'red' ? 'black' : 'red';
                document.getElementById('turn-text').innerText = turn === 'red' ? "ğŸ”´ çº¢æ–¹èµ°æ£‹" : "âš« é»‘æ–¹èµ°æ£‹";
                draw();
            }
        };

        initGame();
    </script>
</body>
</html>