<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>随机迷宫</title>
    <style>
        body { background: #222; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; color: white; font-family: sans-serif; }
        canvas { background: #fff; border-radius: 4px; }
        .controls { margin-top: 15px; text-align: center; color: #aaa; font-size: 14px; }
    </style>
</head>
<body>
    <canvas id="maze" width="400" height="400"></canvas>
    <div class="controls">
        按空格键生成新地图<br>使用方向键移动
    </div>

    <script>
        const canvas = document.getElementById('maze');
        const ctx = canvas.getContext('2d');
        // 迷宫尺寸
        const cols = 20;
        const rows = 20;
        const size = 20; // 单元格像素
        
        let grid = [];
        let current;
        let stack = [];
        let player = {x:0, y:0};
        let goal = {x: cols-1, y: rows-1};

        class Cell {
            constructor(c, r) {
                this.c = c;
                this.r = r;
                this.walls = [true, true, true, true]; // Top, Right, Bottom, Left
                this.visited = false;
            }

            draw() {
                const x = this.c * size;
                const y = this.r * size;
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 2;
                if (this.walls[0]) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + size, y); ctx.stroke(); }
                if (this.walls[1]) { ctx.beginPath(); ctx.moveTo(x + size, y); ctx.lineTo(x + size, y + size); ctx.stroke(); }
                if (this.walls[2]) { ctx.beginPath(); ctx.moveTo(x + size, y + size); ctx.lineTo(x, y + size); ctx.stroke(); }
                if (this.walls[3]) { ctx.beginPath(); ctx.moveTo(x, y + size); ctx.lineTo(x, y); ctx.stroke(); }
            }

            checkNeighbors() {
                let neighbors = [];
                const top = grid[index(this.c, this.r - 1)];
                const right = grid[index(this.c + 1, this.r)];
                const bottom = grid[index(this.c, this.r + 1)];
                const left = grid[index(this.c - 1, this.r)];

                if (top && !top.visited) neighbors.push(top);
                if (right && !right.visited) neighbors.push(right);
                if (bottom && !bottom.visited) neighbors.push(bottom);
                if (left && !left.visited) neighbors.push(left);

                if (neighbors.length > 0) {
                    const r = Math.floor(Math.random() * neighbors.length);
                    return neighbors[r];
                }
                return undefined;
            }
        }

        function index(c, r) {
            if (c < 0 || r < 0 || c >= cols || r >= rows) return -1;
            return c + r * cols;
        }

        function removeWalls(a, b) {
            const x = a.c - b.c;
            if (x === 1) { a.walls[3] = false; b.walls[1] = false; }
            else if (x === -1) { a.walls[1] = false; b.walls[3] = false; }
            const y = a.r - b.r;
            if (y === 1) { a.walls[0] = false; b.walls[2] = false; }
            else if (y === -1) { a.walls[2] = false; b.walls[0] = false; }
        }

        function setup() {
            grid = [];
            stack = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    grid.push(new Cell(c, r));
                }
            }
            current = grid[0];
            
            // 快速生成不需要动画
            while(true) {
                current.visited = true;
                const next = current.checkNeighbors();
                if (next) {
                    next.visited = true;
                    stack.push(current);
                    removeWalls(current, next);
                    current = next;
                } else if (stack.length > 0) {
                    current = stack.pop();
                } else {
                    break;
                }
            }
            player = {x:0, y:0};
            draw();
        }

        function draw() {
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < grid.length; i++) {
                grid[i].draw();
            }

            // Draw Goal
            ctx.fillStyle = "#2ecc71";
            ctx.fillRect(goal.x * size + 4, goal.y * size + 4, size - 8, size - 8);

            // Draw Player
            ctx.fillStyle = "#e74c3c";
            ctx.beginPath();
            ctx.arc(player.x * size + size/2, player.y * size + size/2, size/3, 0, Math.PI*2);
            ctx.fill();
        }

        document.addEventListener('keydown', e => {
            const idx = index(player.x, player.y);
            const cell = grid[idx];
            
            if (e.key === 'ArrowUp' && !cell.walls[0]) player.y--;
            else if (e.key === 'ArrowRight' && !cell.walls[1]) player.x++;
            else if (e.key === 'ArrowDown' && !cell.walls[2]) player.y++;
            else if (e.key === 'ArrowLeft' && !cell.walls[3]) player.x--;
            else if (e.key === ' ') setup();

            draw();

            if (player.x === goal.x && player.y === goal.y) {
                setTimeout(() => { alert("获胜！"); setup(); }, 10);
            }
        });

        setup();
    </script>
</body>
</html>